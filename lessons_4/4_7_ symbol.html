<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Symbol</title>
</head>
<body>
<script>
    //     Символы
    // «Символ» представляет собой уникальный идентификатор.
    // Создаются новые символы с помощью функции Symbol():
    // Создаём новый символ - id
    let id = Symbol();
    // При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

    // Создаём символ id с описанием (именем) "id"
    let id = Symbol("id");

    //------------------------------------------------------------------------------------------------------------------

    // два символа с одинаковым описанием – но они не равны:
    let id1 = Symbol("id");
    let id2 = Symbol("id");

    alert(id1 == id2); // false

    //------------------------------------------------------------------------------------------------------------------

    // Символы не преобразуются автоматически в строки
    let id = Symbol("id");
    alert(id); // TypeError: Cannot convert a Symbol value to a string

    // необходимо явно преобразовать его с помощью метода .toString(), вот так:
    let id = Symbol("id");
    alert(id.toString()); // Symbol(id), теперь работает

    // можем обратиться к свойству symbol.description, чтобы вывести только описание:
    let id = Symbol("id");
    alert(id.description); // id

    //------------------------------------------------------------------------------------------------------------------

    // Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться
    // и перезаписать их из других частей программы.
    let user = {
        name: "Вася"
    };
    let id = Symbol("id");
    user[id] = 1;
    alert(user[id]); // мы можем получить доступ к данным по ключу-символу


    // если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт:
    let user = {name: "Вася"};
    // Объявляем в нашем скрипте свойство "id"
    user.id = "Наш идентификатор";
    // ...другой скрипт тоже хочет свой идентификатор...
    user.id = "Их идентификатор"
    // Ой! Свойство перезаписано сторонней библиотекой!

    //------------------------------------------------------------------------------------------------------------------

    // Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
    let id = Symbol("id");

    let user = {
        name: "Вася",
        [id]: 123 // просто "id: 123" не сработает
    };
    // Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».

    //------------------------------------------------------------------------------------------------------------------

    // Свойства, чьи ключи – символы, не перебираются циклом for..in.
    let id = Symbol("id");
    let user = {
        name: "Вася",
        age: 30,
        [id]: 123
    };
    for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)

    // хотя прямой доступ по символу работает
    alert("Напрямую: " + user[id]);
    // Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут
    // работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство.
    // Object.keys(user) также игнорирует символы.

    //------------------------------------------------------------------------------------------------------------------

    // Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
    let id = Symbol("id");
    let user = {
        [id]: 123
    };
    let clone = Object.assign({}, user);

    alert(clone[id]); // 123

    //------------------------------------------------------------------------------------------------------------------

    // Для чтения (или при отсутствии создания) символа из реестра используется вызов Symbol.for(key).
    // Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его,
    // иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key.
    // Читаем символ из глобального реестра и записываем его в переменную
    let id = Symbol.for("id"); // если символа не существует, он будет создан

    // читаем его снова и записываем в другую переменную (возможно, из другого места кода)
    let idAgain = Symbol.for("id");

    // проверяем -- это один и тот же символ
    alert(id === idAgain); // true
    // Символы, содержащиеся в реестре, называются глобальными символами.
    // Если вам нужен символ, доступный везде в коде – используйте глобальные символы.

    //------------------------------------------------------------------------------------------------------------------

    // метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.
    // получаем символ по имени
    let sym = Symbol.for("name");
    let sym2 = Symbol.for("id");

    // получаем имя по символу
    alert(Symbol.keyFor(sym)); // name
    alert(Symbol.keyFor(sym2)); // id
    // Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа.
    // Так что этот метод не будет работать для не глобальных символов. Если символ не глобальный,
    // метод не сможет его найти и вернёт undefined.

    //------------------------------------------------------------------------------------------------------------------

    // для любых символов доступно свойство description(!)
    let globalSymbol = Symbol.for("name");
    let localSymbol = Symbol("name");

    alert(Symbol.keyFor(globalSymbol)); // name, глобальный символ
    alert(Symbol.keyFor(localSymbol)); // undefined для неглобального символа

    alert(localSymbol.description); // name

    //------------------------------------------------------------------------------------------------------------------

    // Символы имеют два основных варианта использования:
    // (1) «Скрытые» свойства объектов.
    // Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке,
    // мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in,
    // так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением,
    // так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной
    // перезаписи или использования.
    // Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

    // (2)Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*.
    // Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах
    // мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования
    // объектов в примитивы и так далее.
    // Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj)
    // – с его помощью можно получить все свойства объекта с ключами-символами.
    // Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные.

</script>
</body>
</html>
