// setTimeout
// setTimeout ожидает ссылку на функцию
// let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);

// setInterval
// let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
//

// function sayHi(phrase, who) {
//   console.log( phrase + ', ' + who );
// }
// setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

//

// Если первый аргумент является строкой, то JavaScript создаст из неё функцию.
// setTimeout("alert('Привет')", 1000);
// Но использование строк не рекомендуется. Вместо этого используйте функции:
// setTimeout(() => alert('Привет'), 1000);

//

// Отмена через clearTimeout
// Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены
// дальнейшего выполнения.

// let timerId = setTimeout(...);
// clearTimeout(timerId);

//

// Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
// повторить с интервалом 2 секунды
// let timerId = setInterval(() => console.log('tick'), 2000);

// остановить вывод через 5 секунд
// setTimeout(() => { clearInterval(timerId); console.log('stop'); }, 5000);


//

// Например, необходимо написать сервис, который отправляет запрос для получения данных на сервер
// каждые 5 секунд, но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40
// секунд… Вот псевдокод:
// let delay = 5000;
//
// let timerId = setTimeout(function request() {
//   ...отправить запрос...
//
// if (ошибка запроса из-за перегрузки сервера) {
//   увеличить интервал для следующего запроса
// delay *= 2;
// }
//
// timerId = setTimeout(request, delay);
//
// }, delay);

//

// setTimeout(() => alert("Мир"));
// alert("Привет");
// Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь»
// только после того, как текущий код завершится. Поэтому "Привет" выводится первым, а "Мир" – после него.

//----------------------------------------------------------------------------------------------------------------------

// Напишите функцию printNumbers(from, to), которая выводит число каждую секунду, начиная от from и заканчивая to.
// Сделайте два варианта решения:
// Используя setInterval.
// Используя рекурсивный setTimeout.


// // v1.0 my version by setInterval
// function printNumbers(from, to) {
//     let tik = from;
//     let timerID = setInterval(timer, 1000);
//     function timer() {
//         if (tik <= to) {
//             console.log(tik++);
//         } else {
//             clearTimeout(timerID);
//         }
//     }
// }

// v1.1 my version by setTimeout
function printNumbers(from, to) {
    let tik = from;
    setTimeout(function timer() {
        console.log(tik++);
        if (tik <= to){
            setTimeout(timer, 1000);
        }
    }, 1000);
}

// printNumbers(20, 30);


//----------------------------------------------------------------------------------------------------------------------

// В приведённом ниже коде запланирован вызов setTimeout, а затем выполняется сложное вычисление,
// для завершения которого требуется более 100 мс.
//
// Когда будет выполнена запланированная функция?
// После цикла.
// Что покажет alert? - 100000000
// Вызов setTimeout будет выполнен только после того, как текущий код завершится.

let i = 0;
setTimeout(() => console.log(i), 100); // ?
// предположим, что время выполнения этой функции >100 мс
for(let j = 0; j < 1e+8; j++) {
  i++;
}

